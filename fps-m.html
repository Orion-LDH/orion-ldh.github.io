<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D FPS Â∞ÑÂáªÊ∏∏Êàè - ÊûÅÈôêÁîüÂ≠ò (ÁßªÂä®Áâà)</title>
    <style>
        /* Âü∫Á°ÄÊ†∑Âºè‰øùÊåÅ‰∏çÂèò */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
            position: relative;
        }
        #gameCanvas {
            display: block;
            cursor: none;
            width: 100%;
            height: 100%;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 100;
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            transition: background 0.1s, transform 0.1s ease-out, width 0.1s ease-out, height 0.1s ease-out;
        }
        #crosshair::before {
            width: 2px;
            height: 30px;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            width: 30px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #crosshair.hit {
            background: rgba(255, 0, 0, 0.8);
        }
        #crosshair.recoil {
            transform-origin: center center;
            animation: recoilAnimation 0.1s ease-out;
        }
        @keyframes recoilAnimation {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        #crosshair.scope {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
        }
        #crosshair.scope::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 20px;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            background: rgba(0, 255, 0, 0.8);
        }
        #crosshair.scope::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 2px;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 255, 0, 0.8);
        }
        #crosshair.scope .center-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* ÁßªÂä®Á´ØÊéßÂà∂UI */
        .mobile-controls {
            position: fixed;
            z-index: 200;
            display: none;
        }
        
        /* ËôöÊãüÊëáÊùÜ */
        .joystick-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            z-index: 200;
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8);
        }
        
        /* ËßÜËßíÊéßÂà∂Âå∫Âüü */
        .view-control {
            position: fixed;
            top: 0;
            right: 0;
            width: 60%;
            height: 60%;
            z-index: 150;
        }
        
        /* Âä®‰ΩúÊåâÈíÆ */
        .action-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            z-index: 200;
        }
        
        .action-button {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .action-button:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }
        
        .fire-button {
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.6);
        }
        
        .reload-button {
            background: rgba(255, 255, 0, 0.3);
            border-color: rgba(255, 255, 0, 0.6);
        }
        
        .jump-button {
            background: rgba(0, 255, 0, 0.3);
            border-color: rgba(0, 255, 0, 0.6);
        }
        
        .crouch-button {
            background: rgba(0, 0, 255, 0.3);
            border-color: rgba(0, 0, 255, 0.6);
        }
        
        /* Ê≠¶Âô®ÂàáÊç¢ÊåâÈíÆ */
        .weapon-buttons {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            z-index: 200;
        }
        
        .weapon-button {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
        }
        
        .weapon-button.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(0, 255, 0, 0.8);
        }
        
        /* HUDË∞ÉÊï¥ */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        
        #ammo {
            position: fixed;
            bottom: 100px;
            right: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 300;
            width: 80%;
            max-width: 400px;
        }
        
        #gameOver h2 {
            font-size: 28px;
            margin-bottom: 15px;
        }
        
        #gameOver button {
            padding: 12px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            margin: 8px;
        }
        
        #gameOver button:hover {
            background: #45a049;
        }
        
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        
        .hit-marker {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            z-index: 150;
            animation: hitFade 0.5s ease-out;
        }
        
        @keyframes hitFade {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.5);
            }
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 24px;
            flex-direction: column;
        }
        
        #loadingScreen .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        #loadingScreen .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s;
        }
        
        #damageIndicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }
        
        .damage-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255, 0, 0, 0.3) 100%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        #waveIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 120;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        #reloadIndicator {
            position: fixed;
            bottom: 160px;
            right: 20px;
            color: #ffff00;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
        }
        
        .health-bar {
            width: 150px;
            height: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s;
        }
        
        #clickToStart {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 28px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 150;
            opacity: 1;
            transition: opacity 0.5s;
            text-align: center;
            width: 80%;
        }
        
        #minimap {
            position: fixed;
            bottom: 20px;
            left: 180px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            border-radius: 5px;
            z-index: 100;
        }
        
        .weapon-indicator {
            position: fixed;
            bottom: 140px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        
        .powerup-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
        }
        
        .powerup-bar {
            width: 150px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .powerup-fill {
            height: 100%;
            background: linear-gradient(to right, #00ffff, #0080ff);
            transition: width 0.3s;
        }
        
        #killfeed {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 250px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }
        
        .kill-message {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 12px;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .kill-message.enemy {
            border-left: 3px solid #00ff00;
        }
        
        .kill-message.player {
            border-left: 3px solid #ff0000;
        }
        
        #weaponWheel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            display: none;
            z-index: 300;
        }
        
        .weapon-slot {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            transition: all 0.3s;
        }
        
        .weapon-slot.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: #00ff00;
            transform: scale(1.2);
        }
        
        .weapon-slot:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #ffff00;
        }
        
        #scoreMultiplier {
            position: fixed;
            top: 80px;
            left: 20px;
            color: #ffff00;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none;
        }
        
        .combo-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 120;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #powerupNotification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 120;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .shell {
            position: absolute;
            width: 8px;
            height: 12px;
            background: radial-gradient(ellipse at center, #d4af37, #b8860b);
            border-radius: 50% 50% 40% 40%;
            pointer-events: none;
            z-index: 90;
            animation: shellDrop 1.5s ease-out forwards;
        }
        
        @keyframes shellDrop {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(15px, 30px) rotate(180deg);
                opacity: 0;
            }
        }
        
        #stats {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            text-align: right;
        }
        
        .stat-line {
            margin-bottom: 5px;
        }
        
        #weaponStats {
            position: fixed;
            bottom: 180px;
            right: 20px;
            color: white;
            font-size: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            text-align: right;
        }
        
        .accuracy-bar {
            width: 80px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid white;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .accuracy-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s;
        }
        
        .explosion {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,100,0,0.8) 0%, rgba(255,200,0,0.6) 40%, rgba(255,255,0,0.3) 70%, transparent 100%);
            pointer-events: none;
            z-index: 80;
            animation: explode 0.5s ease-out forwards;
        }
        
        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
        
        #headshotIndicator {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 160;
            opacity: 0;
            animation: headshotFade 1s ease-out;
        }
        
        @keyframes headshotFade {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.5);
            }
        }
        
        #weaponUpgradeNotification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 120;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .enemy-type-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .stamina-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid white;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .stamina-fill {
            height: 100%;
            background: linear-gradient(to right, #0080ff, #00ffff);
            transition: width 0.3s;
        }
        
        .radar-pulse {
            position: absolute;
            width: 8px;
            height: 8px;
            background: rgba(0, 255, 0, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 101;
            animation: radarPulse 2s infinite;
        }
        
        @keyframes radarPulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.7;
            }
            100% {
                transform: translate(-50%, -50%) scale(3);
                opacity: 0;
            }
        }
        
        .enemy-spawn-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 130;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .bullet-trail {
            position: absolute;
            width: 2px;
            background: linear-gradient(to bottom, rgba(255,255,0,0.8), rgba(255,255,0,0));
            pointer-events: none;
            z-index: 85;
        }
        
        .muzzle-flash {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,255,0,0.8) 30%, rgba(255,0,0,0.4) 60%, transparent 100%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 95;
            animation: flashFade 0.2s ease-out forwards;
        }
        
        @keyframes flashFade {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        .impact-effect {
            position: absolute;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, rgba(255,255,0,0.8) 0%, rgba(255,100,0,0.6) 40%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 82;
            animation: impactFade 0.3s ease-out forwards;
        }
        
        @keyframes impactFade {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        .recoil-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffff00;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .weapon-sway {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 99;
            transition: all 0.1s;
        }
        
        /* ‰∏æÈïúËßÜÈáéÈÅÆÁΩ© */
        .scope-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.2s ease-out;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0) 30%, rgba(0, 0, 0, 0.7) 100%);
        }
        
        .scope-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            height: 180px;
            border: 3px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
        }
        
        .scope-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }
        
        .scope-crosshair::before,
        .scope-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 0, 0.8);
        }
        
        .scope-crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .scope-crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .scope-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(0, 255, 0, 0.8);
            font-size: 10px;
            font-family: monospace;
        }
        
        /* ÁßªÂä®Á´ØÁâπÂÆöÊ†∑Âºè */
        @media (max-width: 768px) {
            #hud {
                font-size: 14px;
            }
            
            #ammo {
                font-size: 18px;
            }
            
            .weapon-indicator {
                font-size: 12px;
            }
            
            #minimap {
                width: 100px;
                height: 100px;
                left: 170px;
            }
            
            .joystick-container {
                width: 120px;
                height: 120px;
            }
            
            .joystick-stick {
                width: 50px;
                height: 50px;
            }
            
            .action-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .fire-button {
                width: 70px;
                height: 70px;
            }
        }
        
        /* ÁßªÂä®Á´ØÊ®™Â±èÊ®°Âºè */
        @media (orientation: landscape) and (max-height: 500px) {
            #hud {
                top: 10px;
                left: 10px;
                font-size: 12px;
            }
            
            .joystick-container {
                bottom: 10px;
                left: 10px;
                width: 100px;
                height: 100px;
            }
            
            .joystick-stick {
                width: 40px;
                height: 40px;
            }
            
            .action-buttons {
                bottom: 10px;
                right: 10px;
            }
            
            .action-button {
                width: 40px;
                height: 40px;
                font-size: 16px;
                margin-bottom: 5px;
            }
            
            .fire-button {
                width: 60px;
                height: 60px;
            }
            
            #minimap {
                bottom: 10px;
                left: 120px;
                width: 80px;
                height: 80px;
            }
            
            #ammo {
                bottom: 80px;
                right: 10px;
                font-size: 16px;
            }
            
            .weapon-indicator {
                bottom: 110px;
                right: 10px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div>Ê∏∏ÊàèÂä†ËΩΩ‰∏≠...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="loadingProgress"></div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="crosshair"></div>
    <div class="weapon-sway"></div>
    
    <!-- ‰∏æÈïúÁûÑÂáÜË¶ÜÁõñÂ±Ç -->
    <div class="scope-overlay" id="scopeOverlay">
        <div class="scope-circle">
            <div class="scope-crosshair"></div>
            <div class="scope-info" id="scopeInfo">Ë∑ùÁ¶ª: --m</div>
        </div>
    </div>
    
    <!-- ÁßªÂä®Á´ØÊéßÂà∂UI -->
    <div class="mobile-controls" id="mobileControls">
        <!-- ËôöÊãüÊëáÊùÜ -->
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
        
        <!-- ËßÜËßíÊéßÂà∂Âå∫Âüü -->
        <div class="view-control" id="viewControl"></div>
        
        <!-- Âä®‰ΩúÊåâÈíÆ -->
        <div class="action-buttons">
            <div class="action-button fire-button" id="fireButton">üî•</div>
            <div class="action-button reload-button" id="reloadButton">üîÑ</div>
            <div class="action-button jump-button" id="jumpButton">‚¨ÜÔ∏è</div>
            <div class="action-button crouch-button" id="crouchButton">‚¨áÔ∏è</div>
        </div>
        
        <!-- Ê≠¶Âô®ÂàáÊç¢ÊåâÈíÆ -->
        <div class="weapon-buttons">
            <div class="weapon-button active" id="weapon1" data-weapon="rifle">üî´</div>
            <div class="weapon-button" id="weapon2" data-weapon="shotgun">üéØ</div>
            <div class="weapon-button" id="weapon3" data-weapon="sniper">üî≠</div>
            <div class="weapon-button" id="weapon4" data-weapon="smg">üî™</div>
        </div>
    </div>
    
    <div id="hud">
        <div>ÂæóÂàÜ: <span id="score">0</span></div>
        <div>Ê≥¢Ê¨°: <span id="wave">1</span></div>
        <div class="health-bar">
            <div class="health-fill" id="healthBar" style="width: 100%"></div>
        </div>
        <div>‰ΩìÂäõ: <span id="staminaText">100%</span></div>
        <div class="stamina-bar">
            <div class="stamina-fill" id="staminaBar" style="width: 100%"></div>
        </div>
    </div>
    <div id="ammo">
        ÂºπËçØ: <span id="ammoCount">30</span> / <span id="maxAmmo">90</span>
    </div>
    <div id="reloadIndicator">Êç¢Âºπ‰∏≠...</div>
    <div class="weapon-indicator">
        ÂΩìÂâçÊ≠¶Âô®: <span id="currentWeapon">Á™ÅÂáªÊ≠•Êû™</span>
    </div>
    <div id="weaponStats">
        <div>Á≤æÂáÜÂ∫¶: <span id="accuracy">100%</span></div>
        <div class="accuracy-bar">
            <div class="accuracy-fill" id="accuracyBar" style="width: 100%"></div>
        </div>
        <div>ÂáªÊùÄÊï∞: <span id="weaponKills">0</span></div>
        <div>ÂëΩ‰∏≠Áéá: <span id="hitRate">0%</span></div>
    </div>
    <div id="powerupIndicator" style="display: none;">
        <div>ËÉΩÈáè: <span id="powerupName">Êó†</span></div>
        <div class="powerup-bar">
            <div class="powerup-fill" id="powerupBar" style="width: 0%"></div>
        </div>
    </div>
    <div id="scoreMultiplier"></div>
    <div id="minimap">
        <canvas id="minimapCanvas" width="150" height="150"></canvas>
    </div>
    <div id="killfeed"></div>
    <div id="weaponWheel"></div>
    <div id="combo-text"></div>
    <div id="powerupNotification"></div>
    <div id="weaponUpgradeNotification"></div>
    <div id="enemy-type-indicator"></div>
    <div class="enemy-spawn-indicator" id="enemySpawnIndicator"></div>
    <div id="stats">
        <div class="stat-line">ÊÄªÂáªÊùÄ: <span id="totalKills">0</span></div>
        <div class="stat-line">Á≤æÂáÜÂ∞ÑÂáª: <span id="preciseShots">0</span></div>
        <div class="stat-line">ËøûÊùÄÊúÄÈ´ò: <span id="maxCombo">0</span></div>
        <div class="stat-line">Â≠òÊ¥ªÊó∂Èó¥: <span id="survivalTime">0:00</span></div>
    </div>
    <div id="waveIndicator"></div>
    <div id="damageIndicator">
        <div class="damage-overlay"></div>
    </div>
    <div id="clickToStart">ÁÇπÂáªÂ±èÂπïÂºÄÂßãÊ∏∏Êàè</div>
    <div id="gameOver">
        <h2>Ê∏∏ÊàèÁªìÊùü</h2>
        <p>ÊúÄÁªàÂæóÂàÜ: <span id="finalScore">0</span></p>
        <p>Âà∞ËææÊ≥¢Ê¨°: <span id="finalWave">1</span></p>
        <p>ÊÄªÂáªÊùÄÊï∞: <span id="finalKills">0</span></p>
        <p>ÊúÄÈ´òËøûÊùÄ: <span id="finalMaxCombo">0</span></p>
        <p>Â≠òÊ¥ªÊó∂Èó¥: <span id="finalSurvivalTime">0:00</span></p>
        <button onclick="restartGame()">ÈáçÊñ∞ÂºÄÂßã</button>
        <button onclick="location.href='index.html'">ËøîÂõû‰∏ªËèúÂçï</button>
    </div>
    <script>
        // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁßªÂä®ËÆæÂ§á
        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
        }
        
        // Á≠âÂæÖThree.jsÂä†ËΩΩÂÆåÊàê
        function loadScript(src, callback) {
            const script = document.createElement('script');
            script.src = src;
            script.onload = callback;
            script.onerror = () => {
                console.error('Failed to load:', src);
                document.getElementById('loadingScreen').innerHTML = '<div>Âä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢</div>';
            };
            document.head.appendChild(script);
        }
        
        // Âä†ËΩΩThree.js
        loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js', () => {
            // Ê∏∏ÊàèÂèòÈáè
            let scene, camera, renderer;
            let player = {
                position: new THREE.Vector3(0, 2, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: { x: 0, y: 0 },
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                speed: 0.15,
                sprintSpeed: 0.25,
                crouchSpeed: 0.075,
                jumpSpeed: 0.3,
                isGrounded: false,
                radius: 0.5,
                lastDamageTime: 0,
                lastShotTime: 0,
                fireRate: 150,
                kills: 0,
                combo: 0,
                lastKillTime: 0,
                scoreMultiplier: 1,
                powerupActive: null,
                powerupEndTime: 0,
                isSprinting: false,
                isCrouching: false,
                accuracy: 100,
                shotsFired: 0,
                shotsHit: 0,
                weaponKills: 0,
                maxCombo: 0,
                startTime: Date.now(),
                isAiming: false,
                isScoped: false,
                scopedFOV: 30,
                normalFOV: 75,
                fovSpeed: 0.1,
                autoAimEnabled: true, // ÁßªÂä®Á´ØËá™Âä®ÁûÑÂáÜ
                autoAimStrength: 0.3, // Ëá™Âä®ÁûÑÂáÜÂº∫Â∫¶
                autoAimRange: 20 // Ëá™Âä®ÁûÑÂáÜËåÉÂõ¥
            };
            let enemies = [];
            let bullets = [];
            let particles = [];
            let bulletTrails = [];
            let walls = [];
            let crates = [];
            let powerups = [];
            let shells = [];
            let explosions = [];
            let score = 0;
            let ammo = 30;
            let maxAmmo = 90;
            let isReloading = false;
            let gameRunning = false;
            let gameStarted = false;
            let wave = 1;
            let enemiesPerWave = 3;
            let enemiesKilled = 0;
            let waveActive = true;
            let weaponWheelOpen = false;
            let enemyType = 'normal';
            let lastEnemySpawnTime = 0;
            let enemySpawnInterval = 5000;
            let gameTime = 0;
            let enemySpawnTimer = null;
            let waveTransitionTimer = null;
            let isMouseDown = false;
            let shotCooldown = 0;
            let lastAimTime = 0;
            
            // ÁßªÂä®Á´ØÊéßÂà∂ÂèòÈáè
            const isMobile = isMobileDevice();
            let joystickActive = false;
            let joystickVector = { x: 0, y: 0 };
            let viewControlActive = false;
            let viewControlStart = { x: 0, y: 0 };
            let viewControlDelta = { x: 0, y: 0 };
            let fireButtonActive = false;
            let reloadButtonActive = false;
            let jumpButtonActive = false;
            let crouchButtonActive = false;
            
            // Ê≠¶Âô®Á≥ªÁªü
            const weapons = {
                rifle: {
                    name: "Á™ÅÂáªÊ≠•Êû™",
                    damage: 25,
                    fireRate: 150,
                    ammo: 30,
                    maxAmmo: 90,
                    reloadTime: 2000,
                    bulletSpeed: 3,
                    spread: 0.01,
                    recoil: 0.02,
                    muzzleFlash: 0.2,
                    bulletTrail: true,
                    shellEject: true,
                    headshotMultiplier: 2,
                    canAim: true,
                    aimFOV: 40,
                    aimSpeed: 0.15,
                    aimRecoil: 0.01,
                    aimSpread: 0.002,
                    upgradeLevel: 0,
                    maxUpgrade: 3,
                    upgrades: [
                        { name: "Á≤æÂáÜÂ∞ÑÂáª", effect: "spread *= 0.7" },
                        { name: "Âø´ÈÄüÂ∞ÑÂáª", effect: "fireRate *= 0.8" },
                        { name: "È´òÁàÜÂºπ", effect: "damage *= 1.5" }
                    ]
                },
                shotgun: {
                    name: "Èú∞ÂºπÊû™",
                    damage: 15,
                    fireRate: 500,
                    ammo: 8,
                    maxAmmo: 32,
                    reloadTime: 2500,
                    bulletSpeed: 2,
                    spread: 0.15,
                    pellets: 8,
                    recoil: 0.08,
                    muzzleFlash: 0.3,
                    bulletTrail: false,
                    shellEject: true,
                    headshotMultiplier: 1.5,
                    canAim: false,
                    aimFOV: 75,
                    aimSpeed: 0.1,
                    aimRecoil: 0.05,
                    aimSpread: 0.15,
                    upgradeLevel: 0,
                    maxUpgrade: 3,
                    upgrades: [
                        { name: "Êâ©ÂÆπÂºπÂå£", effect: "pellets += 2" },
                        { name: "Âø´ÈÄüË£ÖÂ°´", effect: "reloadTime *= 0.7" },
                        { name: "Á©øÈÄèÂºπ", effect: "damage *= 1.3" }
                    ]
                },
                sniper: {
                    name: "ÁãôÂáªÊ≠•Êû™",
                    damage: 100,
                    fireRate: 1000,
                    ammo: 5,
                    maxAmmo: 20,
                    reloadTime: 3000,
                    bulletSpeed: 5,
                    spread: 0.0005,
                    recoil: 0.12,
                    muzzleFlash: 0.1,
                    bulletTrail: true,
                    shellEject: false,
                    headshotMultiplier: 3,
                    canAim: true,
                    aimFOV: 15,
                    aimSpeed: 0.2,
                    aimRecoil: 0.008,
                    aimSpread: 0.00005,
                    upgradeLevel: 0,
                    maxUpgrade: 3,
                    upgrades: [
                        { name: "È´òÂÄçÈïú", effect: "aimFOV = 8; aimSpread *= 0.3" },
                        { name: "Âø´ÈÄüÁûÑÂáÜ", effect: "fireRate *= 0.8" },
                        { name: "Ëá¥ÂëΩ‰∏ÄÂáª", effect: "headshotMultiplier = 3.5" }
                    ]
                },
                smg: {
                    name: "ÂÜ≤ÈîãÊû™",
                    damage: 15,
                    fireRate: 100,
                    ammo: 40,
                    maxAmmo: 160,
                    reloadTime: 1500,
                    bulletSpeed: 2.5,
                    spread: 0.03,
                    recoil: 0.015,
                    muzzleFlash: 0.15,
                    bulletTrail: true,
                    shellEject: true,
                    headshotMultiplier: 1.8,
                    canAim: true,
                    aimFOV: 50,
                    aimSpeed: 0.12,
                    aimRecoil: 0.008,
                    aimSpread: 0.01,
                    upgradeLevel: 0,
                    maxUpgrade: 3,
                    upgrades: [
                        { name: "È´òÂÆπÈáèÂºπÂå£", effect: "maxAmmo *= 1.5" },
                        { name: "Á®≥ÂÆöÂô®", effect: "recoil *= 0.6" },
                        { name: "Á©øÁî≤Âºπ", effect: "damage *= 1.4" }
                    ]
                }
            };
            let currentWeapon = 'rifle';
            
            // Êïå‰∫∫Á±ªÂûã
            const enemyTypes = {
                normal: {
                    name: "ÊôÆÈÄöÊïå‰∫∫",
                    health: 20,
                    speed: 0.02,
                    shootInterval: 4000,
                    bulletSpeed: 0.6,
                    color: 0xff0000,
                    size: 0.5
                },
                fast: {
                    name: "Âø´ÈÄüÊïå‰∫∫",
                    health: 15,
                    speed: 0.04,
                    shootInterval: 3000,
                    bulletSpeed: 0.8,
                    color: 0xff8800,
                    size: 0.4
                },
                tank: {
                    name: "Âù¶ÂÖãÊïå‰∫∫",
                    health: 50,
                    speed: 0.01,
                    shootInterval: 2000,
                    bulletSpeed: 0.4,
                    color: 0x8800ff,
                    size: 0.7
                },
                sniper: {
                    name: "ÁãôÂáªÊïå‰∫∫",
                    health: 10,
                    speed: 0.015,
                    shootInterval: 1500,
                    bulletSpeed: 1.2,
                    color: 0x00ff00,
                    size: 0.5,
                    longRange: true
                }
            };
            
            // Èü≥ÊïàÁ≥ªÁªü
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const sounds = {};
            
            // ÂàõÂª∫Èü≥Êïà
            function createSound(frequency, duration, type = 'sine', volume = 0.3) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            }
            
            // ÂàõÂª∫Êõ¥Â§çÊùÇÁöÑÈü≥Êïà
            function createComplexSound(frequencies, durations, types = ['sine'], volume = 0.3) {
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        createSound(freq, durations[index], types[index] || 'sine', volume);
                    }, index * 100);
                });
            }
            
            // ÂàùÂßãÂåñÈü≥Êïà
            function initSounds() {
                sounds.shoot = () => createComplexSound([200, 250], [0.1, 0.05], ['square', 'triangle'], 0.2);
                sounds.hit = () => createComplexSound([100, 80], [0.1, 0.1], ['sawtooth', 'square'], 0.3);
                sounds.explosion = () => createComplexSound([50, 100, 150], [0.3, 0.2, 0.1], ['sawtooth', 'sawtooth', 'square'], 0.4);
                sounds.reload = () => createComplexSound([300, 250, 200], [0.1, 0.1, 0.1], ['triangle', 'triangle', 'triangle'], 0.2);
                sounds.powerup = () => createComplexSound([800, 1000, 1200], [0.2, 0.1, 0.1], ['sine', 'sine', 'sine'], 0.3);
                sounds.kill = () => createComplexSound([400, 600, 800, 1000], [0.1, 0.1, 0.1, 0.2], ['sine', 'sine', 'sine', 'sine'], 0.3);
                sounds.combo = () => createComplexSound([600, 800, 1000, 1200], [0.1, 0.1, 0.1, 0.2], ['sine', 'sine', 'sine', 'sine'], 0.3);
                sounds.headshot = () => createComplexSound([1000, 1500, 2000], [0.05, 0.05, 0.1], ['sine', 'sine', 'sine'], 0.4);
                sounds.crouch = () => createSound(150, 0.1, 'triangle', 0.2);
                sounds.jump = () => createSound(400, 0.2, 'sine', 0.3);
                sounds.death = () => createComplexSound([200, 150, 100], [0.2, 0.2, 0.3], ['sawtooth', 'sawtooth', 'sawtooth'], 0.4);
                sounds.upgrade = () => createComplexSound([800, 1000, 1200, 1500], [0.1, 0.1, 0.1, 0.2], ['sine', 'sine', 'sine', 'sine'], 0.3);
                sounds.spawn = () => createComplexSound([300, 400, 500], [0.1, 0.1, 0.1], ['sawtooth', 'sawtooth', 'sawtooth'], 0.3);
                sounds.emptyClick = () => createSound(150, 0.05, 'square', 0.1);
                sounds.reloadStart = () => createSound(200, 0.1, 'triangle', 0.2);
                sounds.reloadEnd = () => createSound(300, 0.1, 'sine', 0.2);
                sounds.aimIn = () => createSound(400, 0.1, 'sine', 0.1);
                sounds.aimOut = () => createSound(300, 0.1, 'sine', 0.1);
            }
            
            // ÊéßÂà∂ÂèòÈáè
            let keys = {};
            let mouse = { x: 0, y: 0, locked: false };
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            
            // Áâ©ÁêÜÂºïÊìé
            const gravity = -0.015;
            const friction = 0.9;
            
            // ÂàùÂßãÂåñThree.js
            function init() {
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
                
                // Ê†πÊçÆËÆæÂ§áË∞ÉÊï¥Ê∏≤ÊüìÂô®ËÆæÁΩÆ
                const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: !isMobile, // ÁßªÂä®ËÆæÂ§áÂÖ≥Èó≠ÊäóÈîØÈΩø‰ª•ÊèêÈ´òÊÄßËÉΩ
                    powerPreference: isMobile ? "high-performance" : "default"
                });
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.fov = player.normalFOV;
                camera.position.copy(player.position);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.mapSize.width = isMobile ? 1024 : 2048; // ÁßªÂä®ËÆæÂ§áÈôç‰ΩéÈò¥ÂΩ±ÂàÜËæ®Áéá
                directionalLight.shadow.mapSize.height = isMobile ? 1024 : 2048;
                scene.add(directionalLight);
                
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0x3a5f3a,
                    side: THREE.DoubleSide
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
                
                const gridHelper = new THREE.GridHelper(100, 50, 0x000000, 0x000000);
                gridHelper.material.opacity = 0.1;
                gridHelper.material.transparent = true;
                scene.add(gridHelper);
                
                createWalls();
                createCrates();
                createMinimap();
                setupEventListeners();
                initSounds();
                
                // ÊòæÁ§∫ÁßªÂä®Á´ØÊéßÂà∂
                if (isMobile) {
                    document.getElementById('mobileControls').style.display = 'block';
                    setupMobileControls();
                }
                
                document.getElementById('loadingScreen').style.display = 'none';
                animate();
            }
            
            // ËÆæÁΩÆÁßªÂä®Á´ØÊéßÂà∂
            function setupMobileControls() {
                // ËôöÊãüÊëáÊùÜÊéßÂà∂
                const joystickContainer = document.getElementById('joystickContainer');
                const joystickStick = document.getElementById('joystickStick');
                
                joystickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickActive = true;
                    const touch = e.touches[0];
                    const rect = joystickContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    updateJoystick(touch.clientX, touch.clientY, centerX, centerY, rect.width / 2);
                });
                
                joystickContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!joystickActive) return;
                    const touch = e.touches[0];
                    const rect = joystickContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    updateJoystick(touch.clientX, touch.clientY, centerX, centerY, rect.width / 2);
                });
                
                joystickContainer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickVector = { x: 0, y: 0 };
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                });
                
                // ËßÜËßíÊéßÂà∂
                const viewControl = document.getElementById('viewControl');
                
                viewControl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    viewControlActive = true;
                    const touch = e.touches[0];
                    viewControlStart = { x: touch.clientX, y: touch.clientY };
                    viewControlDelta = { x: 0, y: 0 };
                });
                
                viewControl.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!viewControlActive) return;
                    const touch = e.touches[0];
                    viewControlDelta.x = touch.clientX - viewControlStart.x;
                    viewControlDelta.y = touch.clientY - viewControlStart.y;
                    
                    // Êõ¥Êñ∞ËßÜËßí
                    const sensitivity = 0.002;
                    targetRotationY -= viewControlDelta.x * sensitivity;
                    targetRotationX -= viewControlDelta.y * sensitivity;
                    targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
                    
                    viewControlStart = { x: touch.clientX, y: touch.clientY };
                });
                
                viewControl.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    viewControlActive = false;
                });
                
                // Â∞ÑÂáªÊåâÈíÆ
                const fireButton = document.getElementById('fireButton');
                fireButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    fireButtonActive = true;
                });
                
                fireButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    fireButtonActive = false;
                });
                
                // Êç¢ÂºπÊåâÈíÆ
                const reloadButton = document.getElementById('reloadButton');
                reloadButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    reloadButtonActive = true;
                    reload();
                });
                
                reloadButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    reloadButtonActive = false;
                });
                
                // Ë∑≥Ë∑ÉÊåâÈíÆ
                const jumpButton = document.getElementById('jumpButton');
                jumpButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    jumpButtonActive = true;
                    if (player.isGrounded) {
                        player.velocity.y = player.jumpSpeed;
                        player.isGrounded = false;
                        sounds.jump();
                    }
                });
                
                jumpButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    jumpButtonActive = false;
                });
                
                // Ëπ≤‰∏ãÊåâÈíÆ
                const crouchButton = document.getElementById('crouchButton');
                crouchButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    crouchButtonActive = true;
                    if (!player.isCrouching) {
                        player.isCrouching = true;
                        player.speed = player.crouchSpeed;
                        camera.position.y = player.position.y - 0.5;
                        sounds.crouch();
                    }
                });
                
                crouchButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    crouchButtonActive = false;
                    player.isCrouching = false;
                    player.speed = 0.15;
                    camera.position.y = player.position.y;
                });
                
                // Ê≠¶Âô®ÂàáÊç¢ÊåâÈíÆ
                const weaponButtons = document.querySelectorAll('.weapon-button');
                weaponButtons.forEach(button => {
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const weaponKey = button.getAttribute('data-weapon');
                        selectWeapon(weaponKey);
                        
                        // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
                        weaponButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                    });
                });
            }
            
            // Êõ¥Êñ∞ËôöÊãüÊëáÊùÜ
            function updateJoystick(touchX, touchY, centerX, centerY, radius) {
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.min(Math.sqrt(dx * dx + dy * dy), radius);
                const angle = Math.atan2(dy, dx);
                
                const x = Math.cos(angle) * distance;
                const y = Math.sin(angle) * distance;
                
                const joystickStick = document.getElementById('joystickStick');
                joystickStick.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
                
                // Êõ¥Êñ∞ÊëáÊùÜÂêëÈáè (Ê†áÂáÜÂåñ)
                joystickVector = {
                    x: x / radius,
                    y: y / radius
                };
            }
            
            // ÂàõÂª∫Â∞èÂú∞Âõæ
            function createMinimap() {
                const minimapCanvas = document.getElementById('minimapCanvas');
                const minimapCtx = minimapCanvas.getContext('2d');
                minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                minimapCtx.fillRect(0, 0, 150, 150);
                minimapCtx.strokeStyle = 'white';
                minimapCtx.lineWidth = 2;
                minimapCtx.strokeRect(2, 2, 146, 146);
            }
            
            // Êõ¥Êñ∞Â∞èÂú∞Âõæ
            function updateMinimap() {
                const minimapCanvas = document.getElementById('minimapCanvas');
                const minimapCtx = minimapCanvas.getContext('2d');
                const scale = isMobile ? 0.8 : 1.46; // ÁßªÂä®Á´ØÂ∞èÂú∞ÂõæÁº©Êîæ
                
                minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                minimapCtx.fillRect(0, 0, 150, 150);
                minimapCtx.strokeStyle = 'white';
                minimapCtx.lineWidth = 2;
                minimapCtx.strokeRect(2, 2, 146, 146);
                
                minimapCtx.fillStyle = 'rgba(139, 105, 20, 0.7)';
                crates.forEach(crate => {
                    const x = (crate.position.x + 50) * scale;
                    const z = (crate.position.z + 50) * scale;
                    minimapCtx.fillRect(x - 2, z - 2, 4, 4);
                });
                
                enemies.forEach(enemy => {
                    const enemyType = enemy.userData.type || 'normal';
                    minimapCtx.fillStyle = `rgba(${parseInt(enemyTypes[enemyType].color.toString(16).substring(0, 2))},
                                             ${parseInt(enemyTypes[enemyType].color.toString(16).substring(2, 4))},
                                             ${parseInt(enemyTypes[enemyType].color.toString(16).substring(4, 6))}, 0.7)`;
                    const x = (enemy.position.x + 50) * scale;
                    const z = (enemy.position.z + 50) * scale;
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, z, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                    
                    if (enemy.userData.state === 'chase' || enemy.userData.state === 'attack') {
                        const pulse = document.createElement('div');
                        pulse.className = 'radar-pulse';
                        pulse.style.left = `${x}px`;
                        pulse.style.top = `${z}px`;
                        document.getElementById('minimap').appendChild(pulse);
                        setTimeout(() => {
                            if (document.getElementById('minimap').contains(pulse)) {
                                document.getElementById('minimap').removeChild(pulse);
                            }
                        }, 2000);
                    }
                });
                
                minimapCtx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                const playerX = (player.position.x + 50) * scale;
                const playerZ = (player.position.z + 50) * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(playerX, playerZ, 4, 0, Math.PI * 2);
                minimapCtx.fill();
                
                minimapCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
                minimapCtx.lineWidth = 2;
                minimapCtx.beginPath();
                minimapCtx.moveTo(playerX, playerZ);
                minimapCtx.lineTo(
                    playerX + Math.sin(player.rotation.y) * 10,
                    playerZ - Math.cos(player.rotation.y) * 10
                );
                minimapCtx.stroke();
            }
            
            // ÂºÄÂßãÊ∏∏Êàè
            function startGame() {
                gameRunning = true;
                gameStarted = true;
                document.getElementById('clickToStart').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('clickToStart').style.display = 'none';
                }, 500);
                startWave();
                updateSurvivalTime();
            }
            
            // ÂàõÂª∫Â¢ôÂ£Å
            function createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({
                    color: 0x8B4513,
                    side: THREE.DoubleSide
                });
                
                const wallPositions = [
                    { x: 0, z: -50, w: 100, h: 10, d: 2 },
                    { x: 0, z: 50, w: 100, h: 10, d: 2 },
                    { x: -50, z: 0, w: 2, h: 10, d: 100 },
                    { x: 50, z: 0, w: 2, h: 10, d: 100 }
                ];
                
                wallPositions.forEach(pos => {
                    const wallGeometry = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(pos.x, pos.h / 2, pos.z);
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    walls.push(wall);
                    scene.add(wall);
                });
            }
            
            // ÂàõÂª∫ÁÆ±Â≠ê
            function createCrates() {
                const crateMaterial = new THREE.MeshLambertMaterial({
                    color: 0x8B6914,
                    side: THREE.DoubleSide
                });
                
                const cratePositions = [
                    { x: -10, z: -10 },
                    { x: 10, z: -10 },
                    { x: -10, z: 10 },
                    { x: 10, z: 10 },
                    { x: 0, z: -20 },
                    { x: 0, z: 20 },
                    { x: -20, z: 0 },
                    { x: 20, z: 0 },
                    { x: -15, z: -15 },
                    { x: 15, z: -15 },
                    { x: -15, z: 15 },
                    { x: 15, z: 15 }
                ];
                
                cratePositions.forEach(pos => {
                    const crateGeometry = new THREE.BoxGeometry(3, 3, 3);
                    const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                    crate.position.set(pos.x, 1.5, pos.z);
                    crate.castShadow = true;
                    crate.receiveShadow = true;
                    crates.push(crate);
                    scene.add(crate);
                });
            }
            
            // ÂàõÂª∫ËÉΩÈáèÈÅìÂÖ∑
            function createPowerup(position, type) {
                const powerupGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 8);
                let powerupMaterial;
                
                switch(type) {
                    case 'health':
                        powerupMaterial = new THREE.MeshLambertMaterial({
                            color: 0x00ff00,
                            emissive: 0x00ff00,
                            emissiveIntensity: 0.3
                        });
                        break;
                    case 'ammo':
                        powerupMaterial = new THREE.MeshLambertMaterial({
                            color: 0xffff00,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.3
                        });
                        break;
                    case 'speed':
                        powerupMaterial = new THREE.MeshLambertMaterial({
                            color: 0x00ffff,
                            emissive: 0x00ffff,
                            emissiveIntensity: 0.3
                        });
                        break;
                    case 'multishot':
                        powerupMaterial = new THREE.MeshLambertMaterial({
                            color: 0xff00ff,
                            emissive: 0xff00ff,
                            emissiveIntensity: 0.3
                        });
                        break;
                    case 'upgrade':
                        powerupMaterial = new THREE.MeshLambertMaterial({
                            color: 0xffd700,
                            emissive: 0xffd700,
                            emissiveIntensity: 0.3
                        });
                        break;
                }
                
                const powerup = new THREE.Mesh(powerupGeometry, powerupMaterial);
                powerup.position.copy(position);
                powerup.userData = { type: type, rotationSpeed: 0.02 };
                
                const ringGeometry = new THREE.RingGeometry(0.6, 0.8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: powerupMaterial.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                powerup.add(ring);
                
                powerups.push(powerup);
                scene.add(powerup);
            }
            
            // Á¢∞ÊíûÊ£ÄÊµã
            function checkCollision(position, radius) {
                for (let wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    const playerSphere = new THREE.Sphere(position, radius);
                    if (wallBox.intersectsSphere(playerSphere)) {
                        return true;
                    }
                }
                
                for (let crate of crates) {
                    const crateBox = new THREE.Box3().setFromObject(crate);
                    const playerSphere = new THREE.Sphere(position, radius);
                    if (crateBox.intersectsSphere(playerSphere)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // ÂºÄÂßãÊñ∞Ê≥¢Ê¨°
            function startWave() {
                if (enemySpawnTimer) {
                    clearTimeout(enemySpawnTimer);
                    enemySpawnTimer = null;
                }
                
                if (waveTransitionTimer) {
                    clearTimeout(waveTransitionTimer);
                    waveTransitionTimer = null;
                }
                
                waveActive = true;
                enemiesKilled = 0;
                
                const waveIndicator = document.getElementById('waveIndicator');
                waveIndicator.textContent = `Á¨¨ ${wave} Ê≥¢`;
                waveIndicator.style.opacity = '1';
                setTimeout(() => {
                    waveIndicator.style.opacity = '0';
                }, 2000);
                
                enemiesPerWave = Math.min(3 + Math.floor(wave / 2), 8);
                const enemyTypeKeys = Object.keys(enemyTypes);
                enemyType = enemyTypeKeys[Math.floor(Math.random() * enemyTypeKeys.length)];
                
                const enemyTypeIndicator = document.getElementById('enemy-type-indicator');
                enemyTypeIndicator.textContent = `Êïå‰∫∫Á±ªÂûã: ${enemyTypes[enemyType].name}`;
                enemyTypeIndicator.style.opacity = '1';
                setTimeout(() => {
                    enemyTypeIndicator.style.opacity = '0';
                }, 3000);
                
                enemySpawnInterval = Math.max(1000, 5000 - wave * 200);
                
                const initialEnemies = Math.min(3, enemiesPerWave);
                for (let i = 0; i < initialEnemies; i++) {
                    setTimeout(() => {
                        spawnEnemy();
                        sounds.spawn();
                    }, i * 1000);
                }
                
                enemySpawnTimer = setInterval(() => {
                    if (gameRunning && waveActive && enemies.length < enemiesPerWave) {
                        const spawnCount = Math.min(2, enemiesPerWave - enemies.length);
                        for (let i = 0; i < spawnCount; i++) {
                            setTimeout(() => {
                                spawnEnemy();
                                sounds.spawn();
                                const spawnIndicator = document.getElementById('enemySpawnIndicator');
                                spawnIndicator.textContent = 'Êïå‰∫∫Êù•Ë¢≠!';
                                spawnIndicator.style.opacity = '1';
                                setTimeout(() => {
                                    spawnIndicator.style.opacity = '0';
                                }, 1000);
                            }, i * 500);
                        }
                    }
                }, enemySpawnInterval);
                
                if (wave % 3 === 0) {
                    const powerupTypes = ['health', 'ammo', 'speed', 'multishot', 'upgrade'];
                    const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 10 + Math.random() * 15;
                    createPowerup(
                        new THREE.Vector3(
                            Math.cos(angle) * distance,
                            0.5,
                            Math.sin(angle) * distance
                        ),
                        randomType
                    );
                }
            }
            
            // ÁîüÊàêÊïå‰∫∫
            function spawnEnemy() {
                const enemyTypeData = enemyTypes[enemyType];
                const enemyGeometry = new THREE.CylinderGeometry(
                    enemyTypeData.size,
                    enemyTypeData.size,
                    2,
                    8
                );
                const enemyMaterial = new THREE.MeshLambertMaterial({
                    color: enemyTypeData.color
                });
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 20;
                enemy.position.set(
                    Math.cos(angle) * distance,
                    1,
                    Math.sin(angle) * distance
                );
                
                enemy.castShadow = true;
                enemy.receiveShadow = true;
                
                const headGeometry = new THREE.SphereGeometry(enemyTypeData.size * 0.8);
                const head = new THREE.Mesh(headGeometry, enemyMaterial);
                head.position.y = 1.2;
                head.castShadow = true;
                enemy.add(head);
                
                const eyeGeometry = new THREE.SphereGeometry(0.1);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 1.3, 0.3);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 1.3, 0.3);
                head.add(leftEye);
                head.add(rightEye);
                
                const baseHealth = enemyTypeData.health;
                const baseSpeed = enemyTypeData.speed;
                const baseShootInterval = enemyTypeData.shootInterval;
                const baseBulletSpeed = enemyTypeData.bulletSpeed;
                
                // ÁßªÂä®Á´ØÈôç‰ΩéÊïå‰∫∫ÈöæÂ∫¶
                const healthMultiplier = isMobile ? 0.8 : 1;
                const speedMultiplier = isMobile ? 0.9 : 1;
                const shootIntervalMultiplier = isMobile ? 1.2 : 1;
                
                enemy.userData = {
                    type: enemyType,
                    health: (baseHealth + wave * 5) * healthMultiplier,
                    maxHealth: (baseHealth + wave * 5) * healthMultiplier,
                    speed: Math.min((baseSpeed + wave * 0.005) * speedMultiplier, 0.08),
                    lastShot: 0,
                    shootInterval: Math.max((baseShootInterval - wave * 200) * shootIntervalMultiplier, 1000),
                    bulletSpeed: Math.min(baseBulletSpeed + wave * 0.05, 1.5),
                    state: 'patrol',
                    patrolCenter: enemy.position.clone(),
                    patrolRadius: 10,
                    lastDirectionChange: Date.now(),
                    lastCoverCheck: Date.now(),
                    targetCover: null,
                    flankingPartner: null,
                    flankingTarget: null,
                    retreatTimer: 0,
                    isLongRange: enemyTypeData.longRange || false
                };
                
                enemies.push(enemy);
                scene.add(enemy);
            }
            
            // ÂØªÊâæÊé©‰Ωì
            function findCover(position, enemy) {
                let bestCover = null;
                let bestScore = -Infinity;
                
                crates.forEach(crate => {
                    const distance = position.distanceTo(crate.position);
                    if (distance < 15 && distance > 2) {
                        const directionToPlayer = new THREE.Vector3()
                            .subVectors(player.position, position)
                            .normalize();
                        const crateDirection = new THREE.Vector3()
                            .subVectors(crate.position, position)
                            .normalize();
                        const dot = directionToPlayer.dot(crateDirection);
                        const score = dot / distance;
                        if (score > bestScore) {
                            bestScore = score;
                            bestCover = crate;
                        }
                    }
                });
                
                return bestCover;
            }
            
            // ÂàõÂª∫Â≠êÂºπËΩ®Ëøπ
            function createBulletTrail(start, end) {
                const points = [];
                points.push(start);
                points.push(end);
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xffff00,
                    opacity: 0.8,
                    transparent: true,
                    linewidth: 2
                });
                
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                
                bulletTrails.push({
                    line: line,
                    life: 10
                });
            }
            
            // Ëá™Âä®ÁûÑÂáÜËæÖÂä©
            function applyAutoAim(direction) {
                if (!player.autoAimEnabled || !isMobile) return direction;
                
                let closestEnemy = null;
                let closestDistance = player.autoAimRange;
                
                // ÂØªÊâæÊúÄËøëÁöÑÊïå‰∫∫
                enemies.forEach(enemy => {
                    const distance = enemy.position.distanceTo(player.position);
                    if (distance < closestDistance) {
                        // Ê£ÄÊü•Êïå‰∫∫ÊòØÂê¶Âú®ËßÜÈáéÂÜÖ
                        const toEnemy = new THREE.Vector3().subVectors(enemy.position, player.position).normalize();
                        const dot = direction.dot(toEnemy);
                        
                        if (dot > 0.7) { // ËßÜÈáéËßíÂ∫¶Á∫¶45Â∫¶
                            closestDistance = distance;
                            closestEnemy = enemy;
                        }
                    }
                });
                
                if (closestEnemy) {
                    // ËÆ°ÁÆóÁûÑÂáÜÊñπÂêë
                    const targetDirection = new THREE.Vector3()
                        .subVectors(closestEnemy.position, player.position)
                        .normalize();
                    
                    // Â∫îÁî®Ëá™Âä®ÁûÑÂáÜÂº∫Â∫¶
                    return direction.lerp(targetDirection, player.autoAimStrength);
                }
                
                return direction;
            }
            
            // Â∞ÑÂáªÁ≥ªÁªü
            function shoot() {
                if (!gameRunning || isReloading) return;
                
                const currentTime = Date.now();
                const weapon = weapons[currentWeapon];
                
                // Ê£ÄÊü•ÂºπËçØ
                if (ammo <= 0) {
                    sounds.emptyClick();
                    return;
                }
                
                // Ê£ÄÊü•Â∞ÑÈÄü
                if (currentTime - player.lastShotTime < weapon.fireRate) return;
                
                player.lastShotTime = currentTime;
                player.shotsFired++;
                shotCooldown = weapon.fireRate;
                
                // ËÆ°ÁÆóÁ≤æÁ°ÆÁöÑÂ≠êÂºπËµ∑Âßã‰ΩçÁΩÆ (Êû™Âè£)
                const gunOffset = new THREE.Vector3(0.3, -0.2, -0.5);
                gunOffset.applyQuaternion(camera.quaternion);
                const bulletStart = camera.position.clone().add(gunOffset);
                
                // ËÆ°ÁÆóÁ≤æÁ°ÆÁöÑÂ≠êÂºπÊñπÂêë
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                let direction = raycaster.ray.direction.clone();
                
                // Â∫îÁî®Ëá™Âä®ÁûÑÂáÜ (‰ªÖÁßªÂä®Á´Ø)
                if (isMobile) {
                    direction = applyAutoAim(direction);
                }
                
                // ËÆ°ÁÆóÊï£Â∏É
                let spreadMultiplier = 1;
                if (player.isScoped && weapon.canAim) {
                    spreadMultiplier = weapon.aimSpread / weapon.spread;
                }
                
                if (weapon.spread > 0) {
                    if (currentWeapon === 'shotgun') {
                        // Èú∞ÂºπÊû™: ÂèëÂ∞ÑÂ§öÈ¢óÂ≠êÂºπÔºåÊØèÈ¢óÈÉΩÊúâËá™Â∑±ÁöÑÊï£Â∏É
                        const coneAngle = weapon.spread * spreadMultiplier;
                        for (let i = 0; i < weapon.pellets; i++) {
                            const pelletDirection = direction.clone();
                            const randomAngleH = (Math.random() - 0.5) * coneAngle;
                            const randomAngleV = (Math.random() - 0.5) * coneAngle * 0.5;
                            pelletDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngleH);
                            pelletDirection.applyAxisAngle(new THREE.Vector3(1, 0, 0), randomAngleV);
                            pelletDirection.normalize();
                            createBullet(bulletStart, pelletDirection, weapon.damage);
                        }
                    } else {
                        // ÂÖ∂‰ªñÊ≠¶Âô®: ÂçïÈ¢óÂ≠êÂºπÔºåÂ∫îÁî®ÊÄª‰ΩìÊï£Â∏É
                        const spread = new THREE.Vector3(
                            (Math.random() - 0.5) * weapon.spread * spreadMultiplier,
                            (Math.random() - 0.5) * weapon.spread * spreadMultiplier * 0.5,
                            (Math.random() - 0.5) * weapon.spread * spreadMultiplier
                        );
                        direction.add(spread);
                        direction.normalize();
                        createBullet(bulletStart, direction, weapon.damage);
                    }
                } else {
                    createBullet(bulletStart, direction, weapon.damage);
                }
                
                // Â∫îÁî®ÂêéÂùêÂäõ
                applyRecoil(weapon.recoil);
                
                // ÂÖ∂‰ªñÊïàÊûú
                sounds.shoot();
                createMuzzleFlash(bulletStart, weapon.muzzleFlash);
                if (weapon.shellEject) {
                    createShellEjection();
                }
                
                // Êõ¥Êñ∞ÂºπËçØÂíåHUD
                ammo--;
                updateHUD();
                if (ammo === 0) {
                    reload();
                }
                updateAccuracy();
            }
            
            // Â∫îÁî®ÂêéÂùêÂäõ
            function applyRecoil(recoilAmount) {
                targetRotationX -= recoilAmount;
                
                const crosshair = document.getElementById('crosshair');
                crosshair.classList.add('recoil');
                setTimeout(() => {
                    crosshair.classList.remove('recoil');
                }, 100);
            }
            
            // ÂàõÂª∫Âçï‰∏™Â≠êÂºπ
            function createBullet(start, direction, damage) {
                const bulletGeometry = new THREE.SphereGeometry(0.05);
                const bulletMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.position.copy(start);
                
                bullet.userData = {
                    velocity: direction.multiplyScalar(weapons[currentWeapon].bulletSpeed),
                    life: 150,
                    damage: damage,
                    trailPositions: [start.clone()]
                };
                
                bullets.push(bullet);
                scene.add(bullet);
            }
            
            // ÂàõÂª∫Êû™Âè£Èó™ÂÖâ
            function createMuzzleFlash(position, intensity = 0.2) {
                const flash = document.createElement('div');
                flash.className = 'muzzle-flash';
                
                const screenPosition = position.clone().project(camera);
                const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
                
                flash.style.left = `${x + (Math.random() - 0.5) * 20}px`;
                flash.style.top = `${y + (Math.random() - 0.5) * 20}px`;
                flash.style.opacity = intensity;
                
                document.body.appendChild(flash);
                setTimeout(() => {
                    if (document.body.contains(flash)) {
                        document.body.removeChild(flash);
                    }
                }, 200);
            }
            
            // ÂàõÂª∫ÂºπÂ£≥ÊéâËêΩÊïàÊûú
            function createShellEjection() {
                const shell = document.createElement('div');
                shell.className = 'shell';
                
                const angle = player.rotation.y + Math.PI + (Math.random() - 0.5) * 0.5;
                const distance = 0.5;
                const x = window.innerWidth / 2 + Math.sin(angle) * distance * 100;
                const y = window.innerHeight / 2 - Math.cos(angle) * distance * 100;
                
                shell.style.left = `${x}px`;
                shell.style.top = `${y}px`;
                
                document.body.appendChild(shell);
                setTimeout(() => {
                    if (document.body.contains(shell)) {
                        document.body.removeChild(shell);
                    }
                }, 1500);
            }
            
            // Êç¢Âºπ
            function reload() {
                if (isReloading || ammo === weapons[currentWeapon].maxAmmo || !gameRunning) return;
                
                isReloading = true;
                document.getElementById('reloadIndicator').style.display = 'block';
                sounds.reloadStart();
                
                setTimeout(() => {
                    const ammoNeeded = weapons[currentWeapon].maxAmmo - ammo;
                    ammo = Math.min(weapons[currentWeapon].maxAmmo, ammo + ammoNeeded);
                    isReloading = false;
                    document.getElementById('reloadIndicator').style.display = 'none';
                    sounds.reloadEnd();
                    updateHUD();
                }, weapons[currentWeapon].reloadTime);
            }
            
            // ÂàõÂª∫Á≤íÂ≠êÊïàÊûú
            function createParticles(position, color = 0xff0000, count = 15) {
                for (let i = 0; i < count; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.08);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.3
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(position);
                    
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.3
                    );
                    
                    particle.userData = {
                        velocity: velocity,
                        life: 40
                    };
                    
                    particles.push(particle);
                    scene.add(particle);
                }
            }
            
            // ÊòæÁ§∫ÂëΩ‰∏≠Ê†áËÆ∞
            function showHitMarker() {
                const crosshair = document.getElementById('crosshair');
                crosshair.classList.add('hit');
                setTimeout(() => {
                    crosshair.classList.remove('hit');
                }, 100);
                
                const hitMarker = document.createElement('div');
                hitMarker.className = 'hit-marker';
                hitMarker.textContent = '‚úï';
                document.body.appendChild(hitMarker);
                setTimeout(() => {
                    if (document.body.contains(hitMarker)) {
                        document.body.removeChild(hitMarker);
                    }
                }, 500);
            }
            
            // ÊòæÁ§∫‰º§ÂÆ≥ÊïàÊûú
            function showDamageEffect() {
                const damageOverlay = document.querySelector('.damage-overlay');
                damageOverlay.style.opacity = '1';
                setTimeout(() => {
                    damageOverlay.style.opacity = '0';
                }, 200);
            }
            
            // Êõ¥Êñ∞HUD
            function updateHUD() {
                document.getElementById('score').textContent = score;
                document.getElementById('wave').textContent = wave;
                document.getElementById('ammoCount').textContent = ammo;
                document.getElementById('maxAmmo').textContent = weapons[currentWeapon].maxAmmo;
                document.getElementById('currentWeapon').textContent = weapons[currentWeapon].name;
                
                const healthPercent = Math.max(0, (player.health / player.maxHealth) * 100);
                document.getElementById('healthBar').style.width = healthPercent + '%';
                
                const staminaPercent = Math.max(0, (player.stamina / player.maxStamina) * 100);
                document.getElementById('staminaBar').style.width = staminaPercent + '%';
                document.getElementById('staminaText').textContent = Math.round(staminaPercent) + '%';
                
                if (player.powerupActive) {
                    const powerupIndicator = document.getElementById('powerupIndicator');
                    powerupIndicator.style.display = 'block';
                    document.getElementById('powerupName').textContent = player.powerupActive;
                    
                    const currentTime = Date.now();
                    const timeLeft = Math.max(0, player.powerupEndTime - currentTime);
                    const duration = 10000;
                    const percent = (timeLeft / duration) * 100;
                    document.getElementById('powerupBar').style.width = percent + '%';
                } else {
                    document.getElementById('powerupIndicator').style.display = 'none';
                }
                
                if (player.scoreMultiplier > 1) {
                    const multiplierIndicator = document.getElementById('scoreMultiplier');
                    multiplierIndicator.textContent = `x${player.scoreMultiplier} ËøûÊùÄ`;
                    multiplierIndicator.style.display = 'block';
                } else {
                    document.getElementById('scoreMultiplier').style.display = 'none';
                }
                
                document.getElementById('weaponKills').textContent = player.weaponKills;
                
                const hitRate = player.shotsFired > 0 ? Math.round((player.shotsHit / player.shotsFired) * 100) : 0;
                document.getElementById('hitRate').textContent = hitRate + '%';
                document.getElementById('accuracyBar').style.width = hitRate + '%';
            }
            
            // Êõ¥Êñ∞Á≤æÂáÜÂ∫¶
            function updateAccuracy() {
                if (player.shotsFired > 0) {
                    const hitRate = player.shotsHit / player.shotsFired;
                    player.accuracy = Math.round(hitRate * 100);
                    document.getElementById('accuracy').textContent = player.accuracy + '%';
                    document.getElementById('accuracyBar').style.width = player.accuracy + '%';
                }
            }
            
            // Êõ¥Êñ∞Â≠òÊ¥ªÊó∂Èó¥
            function updateSurvivalTime() {
                if (!gameRunning) return;
                
                const currentTime = Date.now();
                const elapsed = Math.floor((currentTime - player.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                
                document.getElementById('survivalTime').textContent =
                    `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                
                setTimeout(updateSurvivalTime, 1000);
            }
            
            // Ê∑ªÂä†ÂáªÊùÄ‰ø°ÊÅØ
            function addKillMessage(killer, victim, isPlayer, isHeadshot = false) {
                const killfeed = document.getElementById('killfeed');
                const message = document.createElement('div');
                message.className = `kill-message ${isPlayer ? 'player' : 'enemy'}`;
                
                let text = '';
                if (isPlayer) {
                    text = `‰Ω†${isHeadshot ? 'ÁàÜÂ§¥' : 'ÂáªÊùÄ‰∫Ü'} ${victim}`;
                } else {
                    text = `${killer} ${isHeadshot ? 'ÁàÜÂ§¥' : 'ÂáªÊùÄ‰∫Ü'} ‰Ω†`;
                }
                
                message.textContent = text;
                killfeed.insertBefore(message, killfeed.firstChild);
                
                while (killfeed.children.length > 5) {
                    killfeed.removeChild(killfeed.lastChild);
                }
            }
            
            // ÊòæÁ§∫ËøûÊùÄ‰ø°ÊÅØ
            function showCombo(combo) {
                const comboText = document.getElementById('combo-text');
                comboText.textContent = `${combo} ËøûÊùÄ!`;
                comboText.style.opacity = '1';
                setTimeout(() => {
                    comboText.style.opacity = '0';
                }, 1500);
            }
            
            // ÊòæÁ§∫ËÉΩÈáèÈÅìÂÖ∑ÊèêÁ§∫
            function showPowerupNotification(type) {
                const notification = document.getElementById('powerupNotification');
                let text = '';
                
                switch(type) {
                    case 'health':
                        text = 'ÁîüÂëΩÊÅ¢Â§ç!';
                        break;
                    case 'ammo':
                        text = 'ÂºπËçØË°•ÂÖÖ!';
                        break;
                    case 'speed':
                        text = 'ÈÄüÂ∫¶ÊèêÂçá!';
                        break;
                    case 'multishot':
                        text = 'Â§öÈáçÂ∞ÑÂáª!';
                        break;
                    case 'upgrade':
                        text = 'Ê≠¶Âô®ÂçáÁ∫ß!';
                        break;
                }
                
                notification.textContent = text;
                notification.style.opacity = '1';
                setTimeout(() => {
                    notification.style.opacity = '0';
                }, 2000);
            }
            
            // ÊòæÁ§∫Ê≠¶Âô®ÂçáÁ∫ßÊèêÁ§∫
            function showWeaponUpgradeNotification(weaponName, upgradeName) {
                const notification = document.getElementById('weaponUpgradeNotification');
                notification.textContent = `${weaponName} ÂçáÁ∫ß: ${upgradeName}`;
                notification.style.opacity = '1';
                setTimeout(() => {
                    notification.style.opacity = '0';
                }, 3000);
            }
            
            // ÊòæÁ§∫ÁàÜÂ§¥ÊèêÁ§∫
            function showHeadshotIndicator() {
                const indicator = document.createElement('div');
                indicator.id = 'headshotIndicator';
                indicator.textContent = 'ÁàÜÂ§¥!';
                document.body.appendChild(indicator);
                setTimeout(() => {
                    if (document.body.contains(indicator)) {
                        document.body.removeChild(indicator);
                    }
                }, 1000);
            }
            
            // ÂàõÂª∫ÁàÜÁÇ∏ÊïàÊûú
            function createExplosion(position) {
                const explosion = document.createElement('div');
                explosion.className = 'explosion';
                
                const x = (position.x + 50) * 3;
                const y = (50 - position.z) * 3;
                
                explosion.style.left = `${x}px`;
                explosion.style.top = `${y}px`;
                
                document.body.appendChild(explosion);
                setTimeout(() => {
                    if (document.body.contains(explosion)) {
                        document.body.removeChild(explosion);
                    }
                }, 500);
            }
            
            // Ê∏∏ÊàèÁªìÊùü
            function gameOver() {
                gameRunning = false;
                
                if (mouse.locked) {
                    document.exitPointerLock();
                }
                
                if (enemySpawnTimer) {
                    clearTimeout(enemySpawnTimer);
                    enemySpawnTimer = null;
                }
                
                if (waveTransitionTimer) {
                    clearTimeout(waveTransitionTimer);
                    waveTransitionTimer = null;
                }
                
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalWave').textContent = wave;
                document.getElementById('finalKills').textContent = player.kills;
                document.getElementById('finalMaxCombo').textContent = player.maxCombo;
                document.getElementById('finalSurvivalTime').textContent = document.getElementById('survivalTime').textContent;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            // ÂçáÁ∫ßÊ≠¶Âô®
            function upgradeWeapon(weaponKey) {
                const weapon = weapons[weaponKey];
                if (weapon.upgradeLevel < weapon.maxUpgrade) {
                    weapon.upgradeLevel++;
                    const upgrade = weapon.upgrades[weapon.upgradeLevel - 1];
                    
                    // ‰ΩøÁî®Êõ¥ÂÆâÂÖ®ÁöÑÊñπÂºèÂ∫îÁî®ÂçáÁ∫ß
                    if (upgrade.name === "Á≤æÂáÜÂ∞ÑÂáª") {
                         weapon.spread *= 0.7;
                    } else if (upgrade.name === "Âø´ÈÄüÂ∞ÑÂáª") {
                         weapon.fireRate *= 0.8;
                    } else if (upgrade.name === "È´òÁàÜÂºπ") {
                         weapon.damage *= 1.5;
                    } else if (upgrade.name === "Êâ©ÂÆπÂºπÂå£") {
                         weapon.pellets += 2;
                    } else if (upgrade.name === "Âø´ÈÄüË£ÖÂ°´") {
                         weapon.reloadTime *= 0.7;
                    } else if (upgrade.name === "Á©øÈÄèÂºπ") {
                         weapon.damage *= 1.3;
                    } else if (upgrade.name === "È´òÂÄçÈïú") {
                         weapon.aimFOV = 8;
                         weapon.aimSpread *= 0.3;
                    } else if (upgrade.name === "Âø´ÈÄüÁûÑÂáÜ") {
                         weapon.fireRate *= 0.8;
                    } else if (upgrade.name === "Ëá¥ÂëΩ‰∏ÄÂáª") {
                         weapon.headshotMultiplier = 3.5;
                    } else if (upgrade.name === "È´òÂÆπÈáèÂºπÂå£") {
                         weapon.maxAmmo *= 1.5;
                    } else if (upgrade.name === "Á®≥ÂÆöÂô®") {
                         weapon.recoil *= 0.6;
                    } else if (upgrade.name === "Á©øÁî≤Âºπ") {
                         weapon.damage *= 1.4;
                    }
                    
                    showWeaponUpgradeNotification(weapon.name, upgrade.name);
                    sounds.upgrade();
                    updateHUD();
                }
            }
            
            // ÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
            function restartGame() {
                if (enemySpawnTimer) {
                    clearTimeout(enemySpawnTimer);
                    enemySpawnTimer = null;
                }
                
                if (waveTransitionTimer) {
                    clearTimeout(waveTransitionTimer);
                    waveTransitionTimer = null;
                }
                
                player.health = player.maxHealth;
                player.stamina = player.maxStamina;
                player.position.set(0, 2, 0);
                player.velocity.set(0, 0, 0);
                player.rotation.x = 0;
                player.rotation.y = 0;
                targetRotationX = 0;
                targetRotationY = 0;
                player.stamina = player.maxStamina;
                player.isSprinting = false;
                player.isCrouching = false;
                score = 0;
                ammo = weapons[currentWeapon].ammo;
                wave = 1;
                gameRunning = true;
                enemiesPerWave = 3;
                enemiesKilled = 0;
                player.kills = 0;
                player.combo = 0;
                player.maxCombo = 0;
                player.scoreMultiplier = 1;
                player.powerupActive = null;
                player.shotsFired = 0;
                player.shotsHit = 0;
                player.weaponKills = 0;
                player.startTime = Date.now();
                player.isScoped = false;
                player.isAiming = false;
                camera.fov = player.normalFOV;
                camera.updateProjectionMatrix();
                
                // ÈöêËóè‰∏æÈïúUI
                document.getElementById('crosshair').className = '';
                document.getElementById('scopeOverlay').style.opacity = '0';
                document.getElementById('crosshair').style.display = 'block';
                
                Object.keys(weapons).forEach(key => {
                    weapons[key].upgradeLevel = 0;
                    // ÈáçÁΩÆÊ≠¶Âô®Â±ûÊÄßÂà∞ÂàùÂßãÂÄº
                    if (key === 'rifle') {
                        weapons[key].spread = 0.01;
                        weapons[key].fireRate = 150;
                        weapons[key].damage = 25;
                        weapons[key].recoil = 0.02;
                        weapons[key].aimSpread = 0.002;
                        weapons[key].aimRecoil = 0.01;
                        weapons[key].aimFOV = 40;
                    } else if (key === 'shotgun') {
                        weapons[key].spread = 0.15;
                        weapons[key].fireRate = 500;
                        weapons[key].damage = 15;
                        weapons[key].recoil = 0.08;
                        weapons[key].pellets = 8;
                        weapons[key].aimSpread = 0.15;
                        weapons[key].aimRecoil = 0.05;
                        weapons[key].aimFOV = 75;
                    } else if (key === 'sniper') {
                        weapons[key].spread = 0.0005;
                        weapons[key].fireRate = 1000;
                        weapons[key].damage = 100;
                        weapons[key].recoil = 0.12;
                        weapons[key].aimSpread = 0.00005;
                        weapons[key].aimRecoil = 0.008;
                        weapons[key].aimFOV = 15;
                    } else if (key === 'smg') {
                        weapons[key].spread = 0.03;
                        weapons[key].fireRate = 100;
                        weapons[key].damage = 15;
                        weapons[key].recoil = 0.015;
                        weapons[key].aimSpread = 0.01;
                        weapons[key].aimRecoil = 0.008;
                        weapons[key].aimFOV = 50;
                    }
                });
                
                enemies.forEach(enemy => scene.remove(enemy));
                enemies = [];
                bullets.forEach(bullet => scene.remove(bullet));
                bullets = [];
                particles.forEach(particle => scene.remove(particle));
                particles = [];
                bulletTrails.forEach(trail => scene.remove(trail.line));
                bulletTrails = [];
                powerups.forEach(powerup => scene.remove(powerup));
                powerups = [];
                shells.forEach(shell => {
                    if (document.body.contains(shell)) {
                        document.body.removeChild(shell);
                    }
                });
                shells = [];
                
                document.getElementById('killfeed').innerHTML = '';
                startWave();
                updateHUD();
                document.getElementById('gameOver').style.display = 'none';
            }
            
            // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨
            function setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    keys[e.code] = true;
                    
                    if (e.code === 'KeyR') {
                        reload();
                    }
                    
                    if (e.code === 'Digit1') selectWeapon('rifle');
                    if (e.code === 'Digit2') selectWeapon('shotgun');
                    if (e.code === 'Digit3') selectWeapon('sniper');
                    if (e.code === 'Digit4') selectWeapon('smg');
                    
                    if (e.code === 'KeyQ' && !weaponWheelOpen) {
                        openWeaponWheel();
                    }
                    
                    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                        if (player.stamina > 20) {
                            player.isSprinting = true;
                        }
                    }
                    
                    if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                        if (!player.isCrouching) {
                            player.isCrouching = true;
                            player.speed = player.crouchSpeed;
                            camera.position.y = player.position.y - 0.5;
                            sounds.crouch();
                        }
                    }
                    
                    // ‰∏æÈïúÁûÑÂáÜ - Âè≥ÈîÆ
                    if (e.code === 'AltRight' || e.code === 'AltLeft') {
                        toggleAim();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    keys[e.code] = false;
                    
                    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                        player.isSprinting = false;
                    }
                    
                    if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                        player.isCrouching = false;
                        player.speed = 0.15;
                        camera.position.y = player.position.y;
                    }
                });
                
                document.addEventListener('click', (e) => {
                    if (!gameStarted) {
                        startGame();
                        if (!isMobile) {
                            document.body.requestPointerLock();
                        }
                    } else if (!mouse.locked && gameRunning && !isMobile) {
                        document.body.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    mouse.locked = document.pointerLockElement === document.body;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (mouse.locked && gameRunning && !isMobile) {
                        const sensitivity = player.isScoped ? 0.5 : 1.0;
                        mouseX -= e.movementX * 0.002 * sensitivity;
                        mouseY -= e.movementY * 0.002 * sensitivity;
                        mouseY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, mouseY));
                        targetRotationY = mouseX;
                        targetRotationX = mouseY;
                    }
                    
                    if (weaponWheelOpen) {
                        const weaponWheel = document.getElementById('weaponWheel');
                        const rect = weaponWheel.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                        
                        const weaponSlots = weaponWheel.querySelectorAll('.weapon-slot');
                        weaponSlots.forEach((slot, index) => {
                            const slotAngle = (index / weaponSlots.length) * Math.PI * 2 - Math.PI / 2;
                            const distance = Math.abs(angle - slotAngle);
                            if (distance < 0.3) {
                                slot.classList.add('active');
                            } else {
                                slot.classList.remove('active');
                            }
                        });
                    }
                });
                
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0 && mouse.locked && gameRunning && !isMobile) {
                        isMouseDown = true;
                    }
                    
                    if (weaponWheelOpen && e.button === 0) {
                        const weaponWheel = document.getElementById('weaponWheel');
                        const rect = weaponWheel.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                        
                        const weaponKeys = ['rifle', 'shotgun', 'sniper', 'smg'];
                        weaponKeys.forEach((key, index) => {
                            const slotAngle = (index / weaponKeys.length) * Math.PI * 2 - Math.PI / 2;
                            const distance = Math.abs(angle - slotAngle);
                            if (distance < 0.3) {
                                selectWeapon(key);
                                closeWeaponWheel();
                            }
                        });
                    }
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        isMouseDown = false;
                    }
                });
                
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Èò≤Ê≠¢ÁßªÂä®Á´ØÈªòËÆ§Ëß¶Êë∏Ë°å‰∏∫
                document.addEventListener('touchmove', (e) => {
                    if (e.target.closest('.view-control') || 
                        e.target.closest('.joystick-container') || 
                        e.target.closest('.action-buttons') || 
                        e.target.closest('.weapon-buttons')) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
            
            // ÈÄâÊã©Ê≠¶Âô®
            function selectWeapon(weaponKey) {
                currentWeapon = weaponKey;
                ammo = weapons[weaponKey].ammo;
                updateHUD();
            }
            
            // ÊâìÂºÄÊ≠¶Âô®ËΩÆ
            function openWeaponWheel() {
                weaponWheelOpen = true;
                const weaponWheel = document.getElementById('weaponWheel');
                weaponWheel.style.display = 'block';
                
                const weaponKeys = ['rifle', 'shotgun', 'sniper', 'smg'];
                const weaponIcons = ['üî´', 'üéØ', 'üî≠', 'üî™'];
                
                weaponKeys.forEach((key, index) => {
                    const angle = (index / weaponKeys.length) * Math.PI * 2 - Math.PI / 2;
                    const radius = 100;
                    const x = Math.cos(angle) * radius + 150;
                    const y = Math.sin(angle) * radius + 150;
                    
                    const slot = document.createElement('div');
                    slot.className = 'weapon-slot';
                    if (key === currentWeapon) slot.classList.add('active');
                    slot.style.left = `${x - 30}px`;
                    slot.style.top = `${y - 30}px`;
                    slot.textContent = weaponIcons[index];
                    slot.title = weapons[key].name;
                    
                    if (weapons[key].upgradeLevel > 0) {
                        const upgradeText = document.createElement('div');
                        upgradeText.textContent = `+${weapons[key].upgradeLevel}`;
                        upgradeText.style.position = 'absolute';
                        upgradeText.style.top = '-5px';
                        upgradeText.style.right = '-5px';
                        upgradeText.style.background = '#ffd700';
                        upgradeText.style.color = '#000';
                        upgradeText.style.width = '16px';
                        upgradeText.style.height = '16px';
                        upgradeText.style.borderRadius = '50%';
                        upgradeText.style.display = 'flex';
                        upgradeText.style.justifyContent = 'center';
                        upgradeText.style.alignItems = 'center';
                        upgradeText.style.fontSize = '10px';
                        upgradeText.style.fontWeight = 'bold';
                        slot.appendChild(upgradeText);
                    }
                    
                    weaponWheel.appendChild(slot);
                });
            }
            
            // ÂÖ≥Èó≠Ê≠¶Âô®ËΩÆ
            function closeWeaponWheel() {
                weaponWheelOpen = false;
                const weaponWheel = document.getElementById('weaponWheel');
                weaponWheel.style.display = 'none';
                
                while (weaponWheel.firstChild) {
                    weaponWheel.removeChild(weaponWheel.firstChild);
                }
            }
            
            // ÂàáÊç¢‰∏æÈïúÁûÑÂáÜ
            function toggleAim() {
                const weapon = weapons[currentWeapon];
                if (!weapon.canAim) {
                    return;
                }
                
                player.isScoped = !player.isScoped;
                player.isAiming = true;
                
                const crosshair = document.getElementById('crosshair');
                const scopeOverlay = document.getElementById('scopeOverlay');
                
                if (player.isScoped) {
                    scopeOverlay.style.opacity = '1';
                    sounds.aimIn();
                } else {
                    scopeOverlay.style.opacity = '0';
                    sounds.aimOut();
                }
            }
            
            // Â§ÑÁêÜÁé©ÂÆ∂ËæìÂÖ•
            function handleInput() {
                if (!gameRunning) return;
                
                const moveVector = new THREE.Vector3();
                let speed = player.speed;
                
                if (player.isCrouching) {
                    speed = player.crouchSpeed;
                } else if (player.isSprinting) {
                    speed = player.sprintSpeed;
                    player.stamina = Math.max(0, player.stamina - 0.5);
                } else {
                    player.stamina = Math.min(player.maxStamina, player.stamina + 0.2);
                }
                
                // ‰∏æÈïúÁûÑÂáÜÊó∂ÁßªÂä®ÈÄüÂ∫¶Èôç‰Ωé
                if (player.isScoped) {
                    speed *= 0.3;
                }
                
                // Â§ÑÁêÜÁßªÂä®ËæìÂÖ• (Ê°åÈù¢Á´ØÂíåÁßªÂä®Á´Ø)
                if (isMobile) {
                    // ÁßªÂä®Á´Ø‰ΩøÁî®ËôöÊãüÊëáÊùÜ
                    if (joystickActive) {
                        if (joystickVector.y < -0.2) moveVector.z -= 1;
                        if (joystickVector.y > 0.2) moveVector.z += 1;
                        if (joystickVector.x < -0.2) moveVector.x -= 1;
                        if (joystickVector.x > 0.2) moveVector.x += 1;
                    }
                } else {
                    // Ê°åÈù¢Á´Ø‰ΩøÁî®ÈîÆÁõò
                    if (keys['KeyW']) moveVector.z -= 1;
                    if (keys['KeyS']) moveVector.z += 1;
                    if (keys['KeyA']) moveVector.x -= 1;
                    if (keys['KeyD']) moveVector.x += 1;
                }
                
                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
                    
                    const newPosition = player.position.clone();
                    newPosition.x += moveVector.x * speed;
                    newPosition.z += moveVector.z * speed;
                    
                    if (!checkCollision(newPosition, player.radius)) {
                        player.velocity.x = moveVector.x * speed;
                        player.velocity.z = moveVector.z * speed;
                    } else {
                        newPosition.x = player.position.x;
                        if (!checkCollision(newPosition, player.radius)) {
                            player.velocity.x = 0;
                            player.velocity.z = moveVector.z * speed;
                        } else {
                            newPosition.x = player.position.x + moveVector.x * speed;
                            newPosition.z = player.position.z;
                            if (!checkCollision(newPosition, player.radius)) {
                                player.velocity.x = moveVector.x * speed;
                                player.velocity.z = 0;
                            } else {
                                player.velocity.x = 0;
                                player.velocity.z = 0;
                            }
                        }
                    }
                } else {
                    player.velocity.x *= friction;
                    player.velocity.z *= friction;
                }
                
                if ((keys['Space'] || jumpButtonActive) && player.isGrounded) {
                    player.velocity.y = player.jumpSpeed;
                    player.isGrounded = false;
                    sounds.jump();
                }
            }
            
            // Êõ¥Êñ∞Áé©ÂÆ∂Áâ©ÁêÜ
            function updatePlayerPhysics() {
                player.velocity.y += gravity;
                
                const newPosition = player.position.clone();
                newPosition.add(player.velocity);
                
                if (!checkCollision(newPosition, player.radius)) {
                    player.position.copy(newPosition);
                } else {
                    player.velocity.x = 0;
                    player.velocity.z = 0;
                }
                
                if (player.position.y <= 2) {
                    player.position.y = 2;
                    player.velocity.y = 0;
                    player.isGrounded = true;
                }
                
                player.position.x = Math.max(-48, Math.min(48, player.position.x));
                player.position.z = Math.max(-48, Math.min(48, player.position.z));
                
                player.rotation.x += (targetRotationX - player.rotation.x) * 0.1;
                player.rotation.y += (targetRotationY - player.rotation.y) * 0.1;
                
                camera.position.copy(player.position);
                if (player.isCrouching) {
                    camera.position.y -= 0.5;
                }
                
                camera.rotation.order = 'YXZ';
                camera.rotation.y = player.rotation.y;
                camera.rotation.x = player.rotation.x;
                camera.rotation.z = 0;
            }
            
            // Êõ¥Êñ∞Êïå‰∫∫AI
            function updateEnemies() {
                const currentTime = Date.now();
                
                enemies.forEach((enemy, index) => {
                    const distance = enemy.position.distanceTo(player.position);
                    
                    if (enemy.userData.health <= 0) {
                        createParticles(enemy.position, enemyTypes[enemy.userData.type].color);
                        createExplosion(enemy.position);
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                        
                        player.kills++;
                        player.weaponKills++;
                        player.combo++;
                        
                        if (currentTime - player.lastKillTime < 3000) {
                            if (player.combo >= 3) {
                                player.scoreMultiplier = Math.min(5, Math.floor(player.combo / 3) + 1);
                                showCombo(player.combo);
                                sounds.combo();
                            }
                        } else {
                            player.combo = 1;
                            player.scoreMultiplier = 1;
                        }
                        
                        player.maxCombo = Math.max(player.maxCombo, player.combo);
                        player.lastKillTime = currentTime;
                        
                        const points = 100 * player.scoreMultiplier;
                        score += points;
                        updateHUD();
                        addKillMessage('‰Ω†', enemyTypes[enemy.userData.type].name, true);
                        
                        if (enemiesKilled >= enemiesPerWave && waveActive) {
                            waveActive = false;
                            if (enemySpawnTimer) {
                                clearTimeout(enemySpawnTimer);
                                enemySpawnTimer = null;
                            }
                            wave++;
                            document.getElementById('wave').textContent = wave;
                            waveTransitionTimer = setTimeout(() => {
                                if (gameRunning) {
                                    startWave();
                                }
                            }, 3000);
                        }
                        
                        return;
                    }
                    
                    if (distance < 30) {
                        if (distance < 5) {
                            const direction = new THREE.Vector3()
                                .subVectors(enemy.position, player.position)
                                .normalize();
                            enemy.position.add(direction.multiplyScalar(enemy.userData.speed * 1.5));
                            enemy.userData.state = 'retreat';
                            enemy.userData.retreatTimer = currentTime + 2000;
                        } else {
                            if (enemy.userData.type === 'sniper' && distance > 15) {
                                enemy.userData.state = 'attack';
                                enemy.userData.lastShot = currentTime;
                            } else if (enemy.userData.type === 'fast') {
                                enemy.userData.state = 'chase';
                            } else {
                                if (enemy.userData.state !== 'retreat' &&
                                    currentTime - enemy.userData.lastCoverCheck > 3000) {
                                    enemy.userData.lastCoverCheck = currentTime;
                                    const cover = findCover(enemy.position, enemy);
                                    if (cover) {
                                        enemy.userData.targetCover = cover;
                                        enemy.userData.state = 'flank';
                                    }
                                }
                                
                                if (enemy.userData.state === 'flank' && enemy.userData.targetCover) {
                                    const direction = new THREE.Vector3()
                                        .subVectors(enemy.userData.targetCover.position, enemy.position)
                                        .normalize();
                                    enemy.position.add(direction.multiplyScalar(enemy.userData.speed));
                                    
                                    if (enemy.position.distanceTo(enemy.userData.targetCover.position) < 3) {
                                        enemy.userData.state = 'attack';
                                    }
                                } else if (enemy.userData.state === 'chase' || enemy.userData.state === 'attack') {
                                    const direction = new THREE.Vector3()
                                        .subVectors(player.position, enemy.position)
                                        .normalize();
                                    const randomAngle = (Math.random() - 0.5) * 0.3;
                                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
                                    enemy.position.add(direction.multiplyScalar(enemy.userData.speed));
                                }
                            }
                        }
                    } else {
                        enemy.userData.state = 'patrol';
                        
                        const timeSinceChange = currentTime - enemy.userData.lastDirectionChange;
                        if (timeSinceChange > 3000) {
                            const angle = Math.random() * Math.PI * 2;
                            enemy.userData.patrolCenter = enemy.position.clone();
                            enemy.userData.lastDirectionChange = currentTime;
                        }
                        
                        const patrolDirection = new THREE.Vector3()
                            .subVectors(enemy.userData.patrolCenter, enemy.position)
                            .normalize();
                        enemy.position.add(patrolDirection.multiplyScalar(enemy.userData.speed * 0.5));
                    }
                    
                    if (distance < 30 && currentTime - enemy.userData.lastShot > enemy.userData.shootInterval) {
                        enemy.userData.lastShot = currentTime;
                        
                        const bulletGeometry = new THREE.SphereGeometry(0.05);
                        const bulletMaterial = new THREE.MeshBasicMaterial({
                            color: 0xff00ff,
                            emissive: 0xff00ff,
                            emissiveIntensity: 0.3
                        });
                        
                        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                        bullet.position.copy(enemy.position);
                        bullet.position.y += 1;
                        
                        let errorAngle = 0.3;
                        if (enemy.userData.state === 'chase') {
                            errorAngle = 0.2;
                        } else if (enemy.userData.state === 'attack') {
                            errorAngle = 0.1;
                        } else if (enemy.userData.type === 'sniper') {
                            errorAngle = 0.05;
                        }
                        
                        const direction = new THREE.Vector3()
                            .subVectors(player.position, bullet.position)
                            .normalize();
                        
                        const randomError = (Math.random() - 0.5) * errorAngle;
                        direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomError);
                        
                        bullet.userData = {
                            velocity: direction.multiplyScalar(enemy.userData.bulletSpeed),
                            life: 100,
                            isEnemy: true,
                            damage: 10
                        };
                        
                        bullets.push(bullet);
                        scene.add(bullet);
                    }
                });
            }
            
            // Êõ¥Êñ∞Â≠êÂºπ
            function updateBullets() {
                bullets.forEach((bullet, index) => {
                    const previousPosition = bullet.position.clone();
                    bullet.position.add(bullet.userData.velocity);
                    bullet.userData.life--;
                    
                    if (bullet.userData.trailPositions) {
                        bullet.userData.trailPositions.push(bullet.position.clone());
                        if (bullet.userData.trailPositions.length > 5) {
                            bullet.userData.trailPositions.shift();
                        }
                    }
                    
                    if (bullet.userData.life <= 0) {
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                        return;
                    }
                    
                    if (!bullet.userData.isEnemy) {
                        enemies.forEach(enemy => {
                            if (bullet.position.distanceTo(enemy.position) < 1) {
                                const headPosition = enemy.position.clone();
                                headPosition.y += 1.2;
                                const isHeadshot = bullet.position.distanceTo(headPosition) < 0.5;
                                const damage = bullet.userData.damage;
                                
                                if (isHeadshot) {
                                    enemy.userData.health -= damage * weapons[currentWeapon].headshotMultiplier;
                                    showHeadshotIndicator();
                                    sounds.headshot();
                                } else {
                                    enemy.userData.health -= damage;
                                    sounds.hit();
                                }
                                
                                createParticles(bullet.position, 0xffff00);
                                showHitMarker();
                                player.shotsHit++;
                                updateHUD();
                                
                                scene.remove(bullet);
                                bullets.splice(index, 1);
                            }
                        });
                    } else {
                        if (bullet.position.distanceTo(player.position) < 1) {
                            const currentTime = Date.now();
                            if (currentTime - player.lastDamageTime > 500) {
                                player.health -= bullet.userData.damage;
                                player.lastDamageTime = currentTime;
                                createParticles(bullet.position, 0xff0000);
                                showDamageEffect();
                                updateHUD();
                                
                                if (player.health <= 0) {
                                    gameOver();
                                    addKillMessage('Êïå‰∫∫', '‰Ω†', false);
                                }
                            }
                            
                            scene.remove(bullet);
                            bullets.splice(index, 1);
                        }
                    }
                    
                    if (bullet.position.y <= 0.1) {
                        createParticles(bullet.position, 0x888888);
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                    }
                    
                    for (let wall of walls) {
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        const bulletSphere = new THREE.Sphere(bullet.position, 0.1);
                        
                        if (wallBox.intersectsSphere(bulletSphere)) {
                            createParticles(bullet.position, 0x888888);
                            scene.remove(bullet);
                            bullets.splice(index, 1);
                            break;
                        }
                    }
                });
            }
            
            // Êõ¥Êñ∞Â≠êÂºπËΩ®Ëøπ
            function updateBulletTrails() {
                bulletTrails.forEach((trail, index) => {
                    trail.life--;
                    trail.line.material.opacity = trail.life / 10;
                    
                    if (trail.life <= 0) {
                        scene.remove(trail.line);
                        bulletTrails.splice(index, 1);
                    }
                });
            }
            
            // Êõ¥Êñ∞Á≤íÂ≠ê
            function updateParticles() {
                particles.forEach((particle, index) => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.y -= 0.01;
                    particle.userData.life--;
                    particle.material.opacity = particle.userData.life / 40;
                    
                    if (particle.userData.life <= 0) {
                        scene.remove(particle);
                        particles.splice(index, 1);
                    }
                });
            }
            
            // Êõ¥Êñ∞ËÉΩÈáèÈÅìÂÖ∑
            function updatePowerups() {
                const currentTime = Date.now();
                
                if (player.powerupActive && currentTime > player.powerupEndTime) {
                    player.powerupActive = null;
                    updateHUD();
                }
                
                powerups.forEach((powerup, index) => {
                    powerup.rotation.y += powerup.userData.rotationSpeed;
                    
                    if (powerup.position.distanceTo(player.position) < 1) {
                        switch(powerup.userData.type) {
                            case 'health':
                                player.health = Math.min(player.maxHealth, player.health + 30);
                                showPowerupNotification('health');
                                break;
                            case 'ammo':
                                ammo = weapons[currentWeapon].maxAmmo;
                                showPowerupNotification('ammo');
                                break;
                            case 'speed':
                                player.powerupActive = 'speed';
                                player.powerupEndTime = currentTime + 10000;
                                player.speed = 0.25;
                                player.sprintSpeed = 0.4;
                                showPowerupNotification('speed');
                                break;
                            case 'multishot':
                                player.powerupActive = 'multishot';
                                player.powerupEndTime = currentTime + 10000;
                                showPowerupNotification('multishot');
                                break;
                            case 'upgrade':
                                const weaponKeys = Object.keys(weapons);
                                const randomWeapon = weaponKeys[Math.floor(Math.random() * weaponKeys.length)];
                                upgradeWeapon(randomWeapon);
                                showPowerupNotification('upgrade');
                                break;
                        }
                        
                        sounds.powerup();
                        scene.remove(powerup);
                        powerups.splice(index, 1);
                        updateHUD();
                    }
                });
            }
            
            // Ê∏∏ÊàèÂæ™ÁéØ
            function animate() {
                requestAnimationFrame(animate);
                
                // ‰ºòÂåñÂêéÁöÑ FOV Âπ≥ÊªëËøáÊ∏°
                if (player.isAiming) {
                    const weapon = weapons[currentWeapon];
                    let targetFOV = player.isScoped ? weapon.aimFOV : player.normalFOV;
                    
                    if (Math.abs(camera.fov - targetFOV) > 0.1) {
                        camera.fov += (targetFOV - camera.fov) * player.fovSpeed;
                        camera.updateProjectionMatrix();
                    } else {
                        camera.fov = targetFOV;
                        camera.updateProjectionMatrix();
                        player.isAiming = false;
                        
                        const crosshair = document.getElementById('crosshair');
                        const scopeOverlay = document.getElementById('scopeOverlay');
                        
                        if (player.isScoped) {
                            crosshair.style.display = 'none';
                            crosshair.className = 'scope';
                            if (!crosshair.querySelector('.center-dot')) {
                                const centerDot = document.createElement('div');
                                centerDot.className = 'center-dot';
                                crosshair.appendChild(centerDot);
                            }
                        } else {
                            crosshair.style.display = 'block';
                            crosshair.className = '';
                            const centerDot = crosshair.querySelector('.center-dot');
                            if (centerDot) {
                                centerDot.remove();
                            }
                        }
                    }
                }
                
                // Â§ÑÁêÜÂ∞ÑÂáª
                if ((isMouseDown || fireButtonActive) && gameRunning) {
                    shoot();
                }
                
                // Êõ¥Êñ∞Â∞ÑÂáªÂÜ∑Âç¥
                if (shotCooldown > 0) {
                    shotCooldown -= 16;
                }
                
                handleInput();
                updatePlayerPhysics();
                updateEnemies();
                updateBullets();
                updateBulletTrails();
                updateParticles();
                updatePowerups();
                updateMinimap();
                renderer.render(scene, camera);
            }
            
            // ÂêØÂä®Ê∏∏Êàè
            init();
            updateHUD();
        });
    </script>
</body>
</html>